<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UUIDConvertor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Ristretto</a> &gt; <a href="index.source.html" class="el_package">org.leplus.ristretto.util</a> &gt; <span class="el_source">UUIDConvertor.java</span></div><h1>UUIDConvertor.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016-present Thomas Leplus
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.leplus.ristretto.util;

import java.nio.ByteBuffer;
import java.util.UUID;

/**
 * This class provides utility method to convert different primitives from/to UUID. All the methods
 * in this class are reversible. While this is not a recommended way to generate UUIDs in general,
 * it can be useful in situations where you need to temporarily assign a UUID to an object based on
 * another unique ID.
 *
 * &lt;p&gt;For example if you need to convert a legacy object that has a integer or long ID into a new
 * object that uses UUIDs, you could just generate a new UUID for the new object using {@link
 * java.util.UUID#randomUUID()} but if you need to later link back the legacy object from the new
 * one, you might not have a place to store the legacy ID on the new object. If you use this class's
 * toUUID() methods to convert the legacy object's ID into the new object's UUID, you will be able
 * to later convert back the UUID into the legacy ID. Provided the legacy IDs are unique (at least
 * for the legacy object type), the new UUIDs produced will be as unique.
 *
 * &lt;p&gt;Another use case could be to temporarily convert a legacy object into a new object temporarily
 * (for example for processing via a new method) and then need to convert the result back into a
 * legacy object. Then you can similarly use the methods in this class to go back and forth between
 * legacy IDs and UUIDs.
 *
 * @author Thomas Leplus
 * @since 1.0.0
 */
public final class UUIDConvertor {

  /** Number of bytes in a UUID. */
  public static final int UUID_BYTES = 16;

  /** Maximum number of bytes that can be converted into a UUID. */
  public static final int MAX_BYTES = UUID_BYTES / Byte.BYTES;

  /** Maximum number of shorts that can be converted into a UUID. */
  public static final int MAX_SHORTS = UUID_BYTES / Short.BYTES;

  /** Maximum number of doubles that can be converted into a UUID. */
  public static final int MAX_DOUBLES = UUID_BYTES / Double.BYTES;

  /** Maximum number of floats that can be converted into a UUID. */
  public static final int MAX_FLOATS = UUID_BYTES / Float.BYTES;

  /** Maximum number of characters that can be converted into a UUID. */
  public static final int MAX_CHARS = UUID_BYTES / Character.BYTES;

  /** Maximum number of integers that can be converted into a UUID. */
  public static final int MAX_INTS = UUID_BYTES / Integer.BYTES;

  /** Maximum number of longs that can be converted into a UUID. */
  public static final int MAX_LONGS = UUID_BYTES / Long.BYTES;

  private UUIDConvertor() {
    super();
  }

  private static ByteBuffer allocateByteBuffer() {
<span class="fc" id="L75">    return ByteBuffer.allocate(UUID_BYTES);</span>
  }

  private static ByteBuffer toByteBuffer(final UUID uuid) {
<span class="fc" id="L79">    final ByteBuffer buffer = ByteBuffer.allocate(UUID_BYTES);</span>
<span class="fc" id="L80">    buffer.asLongBuffer().put(uuid.getMostSignificantBits()).put(uuid.getLeastSignificantBits());</span>
<span class="fc" id="L81">    return buffer;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_BYTES} bytes.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static byte[] toBytes(final UUID uuid) {
<span class="fc" id="L91">    return toByteBuffer(uuid).array();</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_CHARS} bytes.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static char[] toChars(final UUID uuid) {
<span class="fc" id="L101">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L102">    final char[] result = new char[MAX_CHARS];</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L104">      result[i] = byteBuffer.getChar();</span>
    }
<span class="fc" id="L106">    return result;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_DOUBLES} bytes.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static double[] toDoubles(final UUID uuid) {
<span class="fc" id="L116">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L117">    final double[] result = new double[MAX_DOUBLES];</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L119">      result[i] = byteBuffer.getDouble();</span>
    }
<span class="fc" id="L121">    return result;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_FLOATS} bytes.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static float[] toFloats(final UUID uuid) {
<span class="fc" id="L131">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L132">    final float[] result = new float[MAX_FLOATS];</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L134">      result[i] = byteBuffer.getFloat();</span>
    }
<span class="fc" id="L136">    return result;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_INTS} bytes.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static int[] toInts(final UUID uuid) {
<span class="fc" id="L146">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L147">    final int[] result = new int[MAX_INTS];</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L149">      result[i] = byteBuffer.getInt();</span>
    }
<span class="fc" id="L151">    return result;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_LONGS} bytes.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static long[] toLongs(final UUID uuid) {
<span class="fc" id="L161">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L162">    final long[] result = new long[MAX_LONGS];</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L164">      result[i] = byteBuffer.getLong();</span>
    }
<span class="fc" id="L166">    return result;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_SHORTS} bytes.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static short[] toShorts(final UUID uuid) {
<span class="fc" id="L176">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L177">    final short[] result = new short[MAX_SHORTS];</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L179">      result[i] = byteBuffer.getShort();</span>
    }
<span class="fc" id="L181">    return result;</span>
  }

  /**
   * Converts an array of up to {@value #MAX_BYTES} bytes into an UUID. If the array is shorter than
   * the maximum length, it will be padded with 0s. If the array is longer than the maximum length,
   * this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param bytes the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_BYTES}.
   */
  public static UUID toUUID(final byte... bytes) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L195" title="All 2 branches covered.">    if (bytes == null) {</span>
<span class="fc" id="L196">      return null;</span>
    }
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">    if (bytes.length &gt; MAX_BYTES) {</span>
<span class="nc" id="L199">      throw new ArrayIndexOutOfBoundsException(bytes.length);</span>
    }
<span class="fc" id="L201">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L202">    byteBuffer.put(bytes);</span>
<span class="fc" id="L203">    return toUUID(byteBuffer);</span>
  }

  private static UUID toUUID(final ByteBuffer bytes) {
<span class="fc" id="L207">    bytes.position(0);</span>
<span class="fc" id="L208">    return new UUID(bytes.getLong(), bytes.getLong());</span>
  }

  /**
   * Converts an array of up to {@value #MAX_CHARS} characters into an UUID. If the array is shorter
   * than the maximum length, it will be padded with 0s. If the array is longer than the maximum
   * length, this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param chars the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_CHARS}.
   */
  public static UUID toUUID(final char... chars) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L222" title="All 2 branches covered.">    if (chars == null) {</span>
<span class="fc" id="L223">      return null;</span>
    }
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">    if (chars.length &gt; MAX_CHARS) {</span>
<span class="nc" id="L226">      throw new ArrayIndexOutOfBoundsException(chars.length);</span>
    }
<span class="fc" id="L228">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L229">    byteBuffer.asCharBuffer().put(chars);</span>
<span class="fc" id="L230">    return toUUID(byteBuffer);</span>
  }

  /**
   * Converts an array of up to {@value #MAX_DOUBLES} doubles into an UUID. If the array is shorter
   * than the maximum length, it will be padded with 0s. If the array is longer than the maximum
   * length, this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param doubles the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_DOUBLES}.
   */
  public static UUID toUUID(final double... doubles) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L244" title="All 2 branches covered.">    if (doubles == null) {</span>
<span class="fc" id="L245">      return null;</span>
    }
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">    if (doubles.length &gt; MAX_DOUBLES) {</span>
<span class="nc" id="L248">      throw new ArrayIndexOutOfBoundsException(doubles.length);</span>
    }
<span class="fc" id="L250">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L251">    byteBuffer.asDoubleBuffer().put(doubles);</span>
<span class="fc" id="L252">    return toUUID(byteBuffer);</span>
  }

  /**
   * Converts an array of up to {@value #MAX_FLOATS} floats into an UUID. If the array is shorter
   * than the maximum length, it will be padded with 0s. If the array is longer than the maximum
   * length, this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param floats the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_FLOATS}.
   */
  public static UUID toUUID(final float... floats) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L266" title="All 2 branches covered.">    if (floats == null) {</span>
<span class="fc" id="L267">      return null;</span>
    }
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">    if (floats.length &gt; MAX_FLOATS) {</span>
<span class="nc" id="L270">      throw new ArrayIndexOutOfBoundsException(floats.length);</span>
    }
<span class="fc" id="L272">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L273">    byteBuffer.asFloatBuffer().put(floats);</span>
<span class="fc" id="L274">    return toUUID(byteBuffer);</span>
  }

  /**
   * Converts an array of up to {@value #MAX_INTS} integers into an UUID. If the array is shorter
   * than the maximum length, it will be padded with 0s. If the array is longer than the maximum
   * length, this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param ints the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value #MAX_INTS}.
   */
  public static UUID toUUID(final int... ints) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L287" title="All 2 branches covered.">    if (ints == null) {</span>
<span class="fc" id="L288">      return null;</span>
    }
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">    if (ints.length &gt; MAX_INTS) {</span>
<span class="nc" id="L291">      throw new ArrayIndexOutOfBoundsException(ints.length);</span>
    }
<span class="fc" id="L293">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L294">    byteBuffer.asIntBuffer().put(ints);</span>
<span class="fc" id="L295">    return toUUID(byteBuffer);</span>
  }

  /**
   * Converts an array of up to {@value #MAX_LONGS} longs into an UUID. If the array is shorter than
   * the maximum length, it will be padded with 0s. If the array is longer than the maximum length,
   * this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param longs the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_LONGS}.
   */
  public static UUID toUUID(final long... longs) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L309" title="All 2 branches covered.">    if (longs == null) {</span>
<span class="fc" id="L310">      return null;</span>
    }
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">    if (longs.length &gt; MAX_LONGS) {</span>
<span class="nc" id="L313">      throw new ArrayIndexOutOfBoundsException(longs.length);</span>
    }
<span class="fc" id="L315">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L316">    byteBuffer.asLongBuffer().put(longs);</span>
<span class="fc" id="L317">    return toUUID(byteBuffer);</span>
  }

  /**
   * Converts an array of up to {@value #MAX_SHORTS} shorts into an UUID. If the array is shorter
   * than the maximum length, it will be padded with 0s. If the array is longer than the maximum
   * length, this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param shorts the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_SHORTS}.
   */
  public static UUID toUUID(final short... shorts) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L331" title="All 2 branches covered.">    if (shorts == null) {</span>
<span class="fc" id="L332">      return null;</span>
    }
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">    if (shorts.length &gt; MAX_SHORTS) {</span>
<span class="nc" id="L335">      throw new ArrayIndexOutOfBoundsException(shorts.length);</span>
    }
<span class="fc" id="L337">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L338">    byteBuffer.asShortBuffer().put(shorts);</span>
<span class="fc" id="L339">    return toUUID(byteBuffer);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>