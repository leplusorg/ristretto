<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UUIDConvertor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Ristretto</a> &gt; <a href="index.source.html" class="el_package">org.leplus.ristretto.util</a> &gt; <span class="el_source">UUIDConvertor.java</span></div><h1>UUIDConvertor.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016-present Thomas Leplus
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.leplus.ristretto.util;

import java.nio.ByteBuffer;
import java.util.UUID;

/**
 * This class provides utility method to convert different primitives from/to UUID. All the methods
 * in this class are reversible. While this is not a recommended way to generate UUIDs in general,
 * it can be useful in situations where you need to temporarily assign a UUID to an object based on
 * another unique ID.
 *
 * &lt;p&gt;For example if you need to convert a legacy object that has a integer or long ID into a new
 * object that uses UUIDs, you could just generate a new UUID for the new object using {@link
 * java.util.UUID#randomUUID()} but if you need to later link back the legacy object from the new
 * one, you might not have a place to store the legacy ID on the new object. If you use this class's
 * toUUID() methods to convert the legacy object's ID into the new object's UUID, you will be able
 * to later convert back the UUID into the legacy ID. Provided the legacy IDs are unique (at least
 * for the legacy object type), the new UUIDs produced will be as unique.
 *
 * &lt;p&gt;Another use case could be to temporarily convert a legacy object into a new object (for
 * example for processing via a new method) and then need to convert the result back into a legacy
 * object. Then you can similarly use the methods in this class to go back and forth between legacy
 * IDs and UUIDs.
 *
 * &lt;p&gt;If the legacy ID that you use has more bits than an UUID (i.e. more than {@value #MAX_BYTES}
 * bytes, {@value #MAX_SHORTS} shorts, {@value #MAX_DOUBLES} doubles, {@value #MAX_FLOATS} floats,
 * {@value #MAX_CHARS} characters, {@value #MAX_INTS} integers, or {@value #MAX_LONGS} longs), you
 * need to truncate your input first. The library does not do this for you because it cannot now
 * which part of the input would provide the best (i.e. unique) input. For example if you have long
 * Strings that need to be converted to UUIDs, you need to choose {@value #MAX_CHARS} characters
 * from these Strings that are guaranteed or very likely to be unique to avoid collisions. Otherwise
 * you should consider using {@link org.leplus.ristretto.util.ReproducibleUUIDs} instead. It won't
 * produce reversible UUIDs but it will maximize the entropy of the produced UUIDs to avoid
 * collisions. If needed, you can maintain a separate Map from the generated UUIDs to the
 * corresponding original input to achieve reversibility.
 *
 * @author Thomas Leplus
 * @since 1.0.0
 */
public final class UUIDConvertor {

  /** Number of bytes in a UUID. */
  public static final int UUID_BYTES = 16;

  /** Maximum number of bytes that can be converted into a UUID. */
  public static final int MAX_BYTES = UUID_BYTES / Byte.BYTES;

  /** Maximum number of shorts that can be converted into a UUID. */
  public static final int MAX_SHORTS = UUID_BYTES / Short.BYTES;

  /** Maximum number of doubles that can be converted into a UUID. */
  public static final int MAX_DOUBLES = UUID_BYTES / Double.BYTES;

  /** Maximum number of floats that can be converted into a UUID. */
  public static final int MAX_FLOATS = UUID_BYTES / Float.BYTES;

  /** Maximum number of characters that can be converted into a UUID. */
  public static final int MAX_CHARS = UUID_BYTES / Character.BYTES;

  /** Maximum number of integers that can be converted into a UUID. */
  public static final int MAX_INTS = UUID_BYTES / Integer.BYTES;

  /** Maximum number of longs that can be converted into a UUID. */
  public static final int MAX_LONGS = UUID_BYTES / Long.BYTES;

  private UUIDConvertor() {
    super();
  }

  private static ByteBuffer allocateByteBuffer() {
<span class="fc" id="L87">    return ByteBuffer.allocate(UUID_BYTES);</span>
  }

  private static ByteBuffer toByteBuffer(final UUID uuid) {
<span class="fc" id="L91">    final ByteBuffer buffer = ByteBuffer.allocate(UUID_BYTES);</span>
<span class="fc" id="L92">    buffer.asLongBuffer().put(uuid.getMostSignificantBits()).put(uuid.getLeastSignificantBits());</span>
<span class="fc" id="L93">    return buffer;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_BYTES} bytes.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static byte[] toBytes(final UUID uuid) {
<span class="fc" id="L103">    return toByteBuffer(uuid).array();</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_CHARS} characters.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static char[] toChars(final UUID uuid) {
<span class="fc" id="L113">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L114">    final char[] result = new char[MAX_CHARS];</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L116">      result[i] = byteBuffer.getChar();</span>
    }
<span class="fc" id="L118">    return result;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_DOUBLES} doubles.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static double[] toDoubles(final UUID uuid) {
<span class="fc" id="L128">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L129">    final double[] result = new double[MAX_DOUBLES];</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L131">      result[i] = byteBuffer.getDouble();</span>
    }
<span class="fc" id="L133">    return result;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_FLOATS} floats.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static float[] toFloats(final UUID uuid) {
<span class="fc" id="L143">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L144">    final float[] result = new float[MAX_FLOATS];</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L146">      result[i] = byteBuffer.getFloat();</span>
    }
<span class="fc" id="L148">    return result;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_INTS} integers.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static int[] toInts(final UUID uuid) {
<span class="fc" id="L158">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L159">    final int[] result = new int[MAX_INTS];</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L161">      result[i] = byteBuffer.getInt();</span>
    }
<span class="fc" id="L163">    return result;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_LONGS} longs.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static long[] toLongs(final UUID uuid) {
<span class="fc" id="L173">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L174">    final long[] result = new long[MAX_LONGS];</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L176">      result[i] = byteBuffer.getLong();</span>
    }
<span class="fc" id="L178">    return result;</span>
  }

  /**
   * Converts a UUID into an array of {@value #MAX_SHORTS} shorts.
   *
   * @param uuid the UUID to convert.
   * @return the resulting array.
   */
  public static short[] toShorts(final UUID uuid) {
<span class="fc" id="L188">    final ByteBuffer byteBuffer = toByteBuffer(uuid);</span>
<span class="fc" id="L189">    final short[] result = new short[MAX_SHORTS];</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L191">      result[i] = byteBuffer.getShort();</span>
    }
<span class="fc" id="L193">    return result;</span>
  }

  /**
   * Converts a UUID into a String of {@value #MAX_CHARS} characters.
   *
   * @param uuid the UUID to convert.
   * @return the resulting String.
   */
  public static String toString(final UUID uuid) {
<span class="fc" id="L203">    return String.valueOf(toChars(uuid));</span>
  }

  /**
   * Converts an array of up to {@value #MAX_BYTES} bytes into an UUID. If the array is shorter than
   * the maximum length, it will be padded with 0s. If the array is longer than the maximum length,
   * this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param bytes the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_BYTES}.
   */
  public static UUID toUUID(final byte... bytes) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L217" title="All 2 branches covered.">    if (bytes == null) {</span>
<span class="fc" id="L218">      return null;</span>
    }
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    if (bytes.length &gt; MAX_BYTES) {</span>
<span class="nc" id="L221">      throw new ArrayIndexOutOfBoundsException(bytes.length);</span>
    }
<span class="fc" id="L223">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L224">    byteBuffer.put(bytes);</span>
<span class="fc" id="L225">    return toUUID(byteBuffer);</span>
  }

  private static UUID toUUID(final ByteBuffer bytes) {
<span class="fc" id="L229">    bytes.position(0);</span>
<span class="fc" id="L230">    return new UUID(bytes.getLong(), bytes.getLong());</span>
  }

  /**
   * Converts an array of up to {@value #MAX_CHARS} characters into an UUID. If the array is shorter
   * than the maximum length, it will be padded with 0s. If the array is longer than the maximum
   * length, this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param chars the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_CHARS}.
   */
  public static UUID toUUID(final char... chars) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L244" title="All 2 branches covered.">    if (chars == null) {</span>
<span class="fc" id="L245">      return null;</span>
    }
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">    if (chars.length &gt; MAX_CHARS) {</span>
<span class="nc" id="L248">      throw new ArrayIndexOutOfBoundsException(chars.length);</span>
    }
<span class="fc" id="L250">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L251">    byteBuffer.asCharBuffer().put(chars);</span>
<span class="fc" id="L252">    return toUUID(byteBuffer);</span>
  }

  /**
   * Converts an array of up to {@value #MAX_DOUBLES} doubles into an UUID. If the array is shorter
   * than the maximum length, it will be padded with 0s. If the array is longer than the maximum
   * length, this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param doubles the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_DOUBLES}.
   */
  public static UUID toUUID(final double... doubles) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L266" title="All 2 branches covered.">    if (doubles == null) {</span>
<span class="fc" id="L267">      return null;</span>
    }
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">    if (doubles.length &gt; MAX_DOUBLES) {</span>
<span class="nc" id="L270">      throw new ArrayIndexOutOfBoundsException(doubles.length);</span>
    }
<span class="fc" id="L272">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L273">    byteBuffer.asDoubleBuffer().put(doubles);</span>
<span class="fc" id="L274">    return toUUID(byteBuffer);</span>
  }

  /**
   * Converts an array of up to {@value #MAX_FLOATS} floats into an UUID. If the array is shorter
   * than the maximum length, it will be padded with 0s. If the array is longer than the maximum
   * length, this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param floats the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_FLOATS}.
   */
  public static UUID toUUID(final float... floats) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L288" title="All 2 branches covered.">    if (floats == null) {</span>
<span class="fc" id="L289">      return null;</span>
    }
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">    if (floats.length &gt; MAX_FLOATS) {</span>
<span class="nc" id="L292">      throw new ArrayIndexOutOfBoundsException(floats.length);</span>
    }
<span class="fc" id="L294">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L295">    byteBuffer.asFloatBuffer().put(floats);</span>
<span class="fc" id="L296">    return toUUID(byteBuffer);</span>
  }

  /**
   * Converts an array of up to {@value #MAX_INTS} integers into an UUID. If the array is shorter
   * than the maximum length, it will be padded with 0s. If the array is longer than the maximum
   * length, this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param ints the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value #MAX_INTS}.
   */
  public static UUID toUUID(final int... ints) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L309" title="All 2 branches covered.">    if (ints == null) {</span>
<span class="fc" id="L310">      return null;</span>
    }
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">    if (ints.length &gt; MAX_INTS) {</span>
<span class="nc" id="L313">      throw new ArrayIndexOutOfBoundsException(ints.length);</span>
    }
<span class="fc" id="L315">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L316">    byteBuffer.asIntBuffer().put(ints);</span>
<span class="fc" id="L317">    return toUUID(byteBuffer);</span>
  }

  /**
   * Converts an array of up to {@value #MAX_LONGS} longs into an UUID. If the array is shorter than
   * the maximum length, it will be padded with 0s. If the array is longer than the maximum length,
   * this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param longs the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_LONGS}.
   */
  public static UUID toUUID(final long... longs) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L331" title="All 2 branches covered.">    if (longs == null) {</span>
<span class="fc" id="L332">      return null;</span>
    }
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">    if (longs.length &gt; MAX_LONGS) {</span>
<span class="nc" id="L335">      throw new ArrayIndexOutOfBoundsException(longs.length);</span>
    }
<span class="fc" id="L337">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L338">    byteBuffer.asLongBuffer().put(longs);</span>
<span class="fc" id="L339">    return toUUID(byteBuffer);</span>
  }

  /**
   * Converts an array of up to {@value #MAX_SHORTS} shorts into an UUID. If the array is shorter
   * than the maximum length, it will be padded with 0s. If the array is longer than the maximum
   * length, this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param shorts the array to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided array is longer than {@value
   *     #MAX_SHORTS}.
   */
  public static UUID toUUID(final short... shorts) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L353" title="All 2 branches covered.">    if (shorts == null) {</span>
<span class="fc" id="L354">      return null;</span>
    }
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">    if (shorts.length &gt; MAX_SHORTS) {</span>
<span class="nc" id="L357">      throw new ArrayIndexOutOfBoundsException(shorts.length);</span>
    }
<span class="fc" id="L359">    final ByteBuffer byteBuffer = allocateByteBuffer();</span>
<span class="fc" id="L360">    byteBuffer.asShortBuffer().put(shorts);</span>
<span class="fc" id="L361">    return toUUID(byteBuffer);</span>
  }

  /**
   * Converts a String of up to {@value #MAX_CHARS} characters into an UUID. If the String is
   * shorter than the maximum length, it will be padded with 0s. If the String is longer than the
   * maximum length, this method will throw an ArrayIndexOutOfBoundsException.
   *
   * @param string the String to convert.
   * @return the resulting UUID.
   * @throws ArrayIndexOutOfBoundsException if the provided String is longer than {@value
   *     #MAX_CHARS}.
   */
  public static UUID toUUID(final String string) throws ArrayIndexOutOfBoundsException {
<span class="fc bfc" id="L375" title="All 2 branches covered.">    if (string == null) {</span>
<span class="fc" id="L376">      return null;</span>
    }
<span class="fc" id="L378">    return toUUID(string.toCharArray());</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>