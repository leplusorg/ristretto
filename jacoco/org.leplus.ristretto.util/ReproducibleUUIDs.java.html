<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReproducibleUUIDs.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Ristretto</a> &gt; <a href="index.source.html" class="el_package">org.leplus.ristretto.util</a> &gt; <span class="el_source">ReproducibleUUIDs.java</span></div><h1>ReproducibleUUIDs.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016-present Thomas Leplus
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.leplus.ristretto.util;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.LongBuffer;
import java.nio.charset.StandardCharsets;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.UUID;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * &lt;p&gt;
 * This class contains utility methods that generate deterministic UUIDs.
 * Meaning that given the same input, these methods will always return the
 * same UUID, as opposed to {@link java.util.UUID#randomUUID()}. The produced
 * UUIDs may not be universally unique (since other code using the same method
 * on the same input would have produce the same UUIDs) but it can still be
 * useful in situations where you need exactly that: be able to generate a UUID
 * and now that other parts of a system will be able to generate a matching
 * UUID for the same input.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example if two parts of a system receive a file and need to
 * independently produce pieces of data that will later have to be reconciled.
 * Then each piece of data could have it's own unique UUID plus a reference
 * UUID generated from the file using one of the methods below. Then both
 * parts of the system will have generated the same reference UUID allowing
 * for easier reconciliation.
 * &lt;/p&gt;
 *
 * @author Thomas Leplus
 * @since 1.0.0
 */
@SuppressFBWarnings(&quot;WEAK_MESSAGE_DIGEST_MD5&quot;)
public final class ReproducibleUUIDs {

  /**
   * Underlying hash algorithm. MD5 is OK since we do not need a one-way
   * hash function.
   */
  private static final String MD5 = &quot;MD5&quot;;

  /**
   * Bytes per UUID.
   */
  private static final int UUID_BYTES = 16;

  /**
   * Buffer size for digest.
   */
  private static final int BUFFER_SIZE = 8192;

  private ReproducibleUUIDs() {
    super();
  }

  /**
   * Generates a UUID from the given String. The same String will always
   * produce the same UUID.
   *
   * @param s the input string.
   * @return the resulting UUID.
   */
  public static UUID fromString(final String s) {
<span class="fc bfc" id="L85" title="All 2 branches covered.">    if (s == null) {</span>
<span class="fc" id="L86">      return null;</span>
    }
<span class="fc" id="L88">    return fromBytes(s.getBytes(StandardCharsets.UTF_8));</span>
  }

  /**
   * Generates a UUID from the given bytes. The same bytes will always produce
   * the same UUID.
   *
   * @param bytes the input bytes.
   * @return the resulting UUID.
   */
  public static UUID fromBytes(final byte... bytes) {
<span class="fc bfc" id="L99" title="All 2 branches covered.">    if (bytes == null) {</span>
<span class="fc" id="L100">      return null;</span>
    }
<span class="fc" id="L102">    final MessageDigest md = createDigest();</span>
<span class="fc" id="L103">    md.update(bytes);</span>
<span class="fc" id="L104">    return digest(md);</span>
  }

  /**
   * Generates a UUID from the given byte buffer. The same bytes will always
   * produce the same UUID.
   *
   * @param buffer the input byte buffer.
   * @return the resulting UUID.
   */
  public static UUID fromByteBuffer(final ByteBuffer buffer) {
<span class="fc bfc" id="L115" title="All 2 branches covered.">    if (buffer == null) {</span>
<span class="fc" id="L116">      return null;</span>
    }
<span class="fc" id="L118">    final MessageDigest md = createDigest();</span>
<span class="fc" id="L119">    md.update(buffer);</span>
<span class="fc" id="L120">    return digest(md);</span>
  }

  @SuppressWarnings(&quot;checkstyle:magicnumber&quot;)
  private static UUID digest(final MessageDigest md) {
<span class="fc" id="L125">    final byte[] md5Bytes = md.digest();</span>
    // for compatibility with UUID.nameUUIDFromBytes(byte[]).
<span class="fc" id="L127">    md5Bytes[6] &amp;= 0x0f;</span>
<span class="fc" id="L128">    md5Bytes[6] |= 0x30;</span>
<span class="fc" id="L129">    md5Bytes[8] &amp;= 0x3f;</span>
<span class="fc" id="L130">    md5Bytes[8] |= 0x80;</span>
<span class="fc" id="L131">    return UUIDConvertor.toUUID(md5Bytes);</span>
  }

  private static MessageDigest createDigest() {
    try {
      /*
       * MD5 is not secure but it's OK in this case since we just need good
       * entropy, not actual security. Also MD5 gives us exactly the 128 bits
       * we need to create a UUID.
       */
<span class="fc" id="L141">      return MessageDigest.getInstance(MD5);</span>
<span class="nc" id="L142">    } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L143">      throw new IllegalStateException(MD5 + &quot; not supported&quot;, e);</span>
    }
  }

  /**
   * Generates a UUID from the given input stream. The same bytes will always
   * produce the same UUID.
   *
   * @param input the input stream.
   * @return the resulting UUID.
   * @throws IOException if an I/O error occurs.
   */
  @SuppressWarnings({ &quot;PMD.EmptyWhileStmt&quot;,
      &quot;PMD.EmptyControlStatement&quot;,
      &quot;checkstyle:emptyblock&quot; })
  public static UUID fromInputStream(final InputStream input)
      throws IOException {
<span class="fc bfc" id="L160" title="All 2 branches covered.">    if (input == null) {</span>
<span class="fc" id="L161">      return null;</span>
    }
<span class="fc" id="L163">    final MessageDigest md = createDigest();</span>
<span class="fc" id="L164">    try (DigestInputStream dis = new DigestInputStream(input, md)) {</span>
<span class="fc" id="L165">      final byte[] buffer = new byte[BUFFER_SIZE];</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">      while (dis.read(buffer) &gt;= 0) {</span>
      }
    }
<span class="fc" id="L169">    return digest(md);</span>
  }

  /**
   * Generates a UUID from the given UUIDs. The same UUIDs will always produce
   * the same UUID.
   *
   * @param uuids the UUIDs.
   * @return the resulting UUID.
   */
  public static UUID fromUUIDs(final UUID... uuids) {
<span class="pc bpc" id="L180" title="1 of 4 branches missed.">    if (uuids == null || uuids.length == 0) {</span>
<span class="fc" id="L181">      return null;</span>
    }
<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (uuids.length == 1) {</span>
<span class="fc" id="L184">      return uuids[0];</span>
    }
<span class="fc" id="L186">    final ByteBuffer bytes = ByteBuffer.allocate(uuids.length * UUID_BYTES);</span>
<span class="fc" id="L187">    final LongBuffer longs = bytes.asLongBuffer();</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">    for (final UUID uuid : uuids) {</span>
<span class="fc" id="L189">      longs.put(uuid.getMostSignificantBits());</span>
<span class="fc" id="L190">      longs.put(uuid.getLeastSignificantBits());</span>
    }
<span class="fc" id="L192">    return fromByteBuffer(bytes);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>